# -*- coding: utf-8 -*-
"""lung disease prediction using MobileNet

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vsuETqUnZcW5R9HWvmG-RfFkiZesmcSv
"""

! kaggle datasets download -d mohamedhanyyy/chest-ctscan-images

! unzip /content/chest-ctscan-images.zip

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Model
from tensorflow.keras.layers import GlobalAveragePooling2D, Dense, Dropout
from tensorflow.keras.callbacks import ReduceLROnPlateau
from tensorflow.keras.applications import EfficientNetB0

# Define paths
train_dir = '/content/Data/train'
valid_dir = '/content/Data/valid'
test_dir = '/content/Data/test'

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications.mobilenet import preprocess_input

def preprocess_image1(img_path):
    'input = path'
    'output = pre processed img'
    image_data = ImageDataGenerator(zoom_range=0.2, shear_range= 0.2, preprocessing_function=preprocess_input, horizontal_flip=True)
    image = image_data.flow_from_directory(directory=img_path, target_size=(224, 224), batch_size=32, class_mode='categorical')
    return image

img_path = '/content/Data/train'
train_data = preprocess_image1(img_path)

def preprocess_image2(img_path):
    'input = path'
    'output = pre processed img'
    image_data = ImageDataGenerator(preprocessing_function=preprocess_input)
    image = image_data.flow_from_directory(directory=img_path, target_size=(224, 224), batch_size=32, class_mode='categorical')
    return image

img_path = '/content/Data/valid'
val_data = preprocess_image2(img_path)

img_path = '/content/Data/test'
test_data = preprocess_image2(img_path)

import numpy as np
import matplotlib.pyplot as plt
from keras.layers import Dense, Flatten
from keras.models import Model
from keras.applications.mobilenet import MobileNet

# model training yaha se

base_model = MobileNet(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(1024, activation='relu')(x)
x = Dropout(0.5)(x)
predictions = Dense(4, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=predictions)

for layer in base_model.layers:
    layer.trainable = False

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

hs = model.fit(train_data, epochs=10, validation_data=val_data)

# Unfreeze some layers of the base model for fine-tuning
for layer in base_model.layers[:70]:
    layer.trainable = False
for layer in base_model.layers[70:]:
    layer.trainable = True

# Recompile the model with a lower learning rate for fine-tuning
model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.00001), loss='categorical_crossentropy', metrics=['accuracy'])

reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.2, patience=3, min_lr=0.00001)


# Fine-tune the model
history_fine = model.fit(
    train_data,
    epochs=15,  # Increase the epochs for fine-tuning
    validation_data=val_data,
    callbacks=[reduce_lr]
)

model.save('chest_cancer_model_fine_tuned.h5')

# model graphical interpretation

h = history_fine.history
h.keys()

import matplotlib.pyplot as plt
plt.plot(h['accuracy'])
plt.plot(h['val_accuracy'], c='red')

plt.title('acc vs val_acc')
plt.xlabel('epoch')
plt.ylabel('accuracy')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

import matplotlib.pyplot as plt
plt.plot(h['accuracy'])
plt.plot(h['val_loss'], c='red')

plt.title('acc vs val_loss')
plt.xlabel('epoch')
plt.ylabel('accuracy')
plt.legend(['train', 'val'], loc='upper left')
plt.show()

from tensorflow.keras.models import load_model
model = load_model('chest_cancer_model_fine_tuned.h5')

acc = model.evaluate(test_data)[1]
print(f'Test Accuracy: {acc:.4f}')

# Plotting the accuracy and loss curves
import matplotlib.pyplot as plt

def plot_history(history, title):
    acc = history.history['accuracy']
    val_acc = history.history['val_accuracy']
    loss = history.history['loss']
    val_loss = history.history['val_loss']
    epochs = range(1, len(acc) + 1)

    plt.figure(figsize=(14, 5))

    plt.subplot(1, 2, 1)
    plt.plot(epochs, acc, 'b', label='Training accuracy')
    plt.plot(epochs, val_acc, 'r', label='Validation accuracy')
    plt.title(f'{title} - Training and validation accuracy')
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.plot(epochs, loss, 'b', label='Training loss')
    plt.plot(epochs, val_loss, 'r', label='Validation loss')
    plt.title(f'{title} - Training and validation loss')
    plt.legend()

    plt.show()

plot_history(hs, 'Before Fine-tuning')
plot_history(history_fine, 'After Fine-tuning')

from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.applications.mobilenet import preprocess_input

def predict_image(img_path, model):
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = preprocess_input(img_array)
    img_array = np.expand_dims(img_array, axis=0)

    prediction = model.predict(img_array)
    class_labels = ['Adenocarcinoma', 'Large cell carcinoma', 'Normal', 'Squamous cell carcinoma']  # Replace with your actual class labels
    predicted_class = class_labels[np.argmax(prediction)]
    confidence = np.max(prediction)

    plt.imshow(img)
    plt.title(f'Prediction: {predicted_class} (Confidence: {confidence:.2f})')
    plt.axis('off')
    plt.show()

# Get image path from user
image_path = input("Enter the path to the image: ")

# Load the fine-tuned model
model = load_model('chest_cancer_model_fine_tuned.h5')

# Predict and display the result
predict_image(image_path, model)

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt

# Load the trained model
model = tf.keras.models.load_model('/content/chest_cancer_model_fine_tuned.h5')

# Function to load and preprocess the image
def load_and_preprocess_image(img_path):
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
    img_array /= 255.0  # Normalize to [0, 1]
    return img_array

# Function to predict the class of the image
def predict_image_class(model, img_array):
    predictions = model.predict(img_array)
    predicted_class = np.argmax(predictions, axis=1)
    return predicted_class, predictions

# Load and preprocess the custom image
img_path = '/content/Data/test/adenocarcinoma/000115.png'  # Replace with your image path
img_array = load_and_preprocess_image(img_path)

# Predict the class of the custom image
predicted_class, predictions = predict_image_class(model, img_array)

# Map the predicted class index to the corresponding class label
class_labels = ['Adenocarcinoma', 'Large cell carcinoma', 'Squamous cell carcinoma', 'Normal']

print(f"Predicted Class: {class_labels[predicted_class[0]]}")
print(f"Prediction Probabilities: {predictions}")

# Plot the image with the predicted label
plt.imshow(image.load_img(img_path))
plt.title(f"Predicted Class: {class_labels[predicted_class[0]]}")
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc
import seaborn as sns

# Predict on the test set
y_pred = model.predict(test_data)
y_pred_classes = np.argmax(y_pred, axis=1)

# Get true labels from the test set (assuming you have them)
y_true = test_data.classes  # Replace with your actual true labels

# Confusion Matrix
cm = confusion_matrix(y_true, y_pred_classes)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=class_labels, yticklabels=class_labels)
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

# Classification Report
print(classification_report(y_true, y_pred_classes, target_names=class_labels))

# ROC Curve and AUC (assuming binary classification for simplicity)
if len(class_labels) == 2:
    fpr, tpr, thresholds = roc_curve(y_true, y_pred[:, 1])
    roc_auc = auc(fpr, tpr)

    plt.figure()
    plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic')
    plt.legend(loc="lower right")
    plt.show()

# Plotting Accuracy and Loss
plot_history(hs, 'Before Fine-tuning')
plot_history(history_fine, 'After Fine-tuning')

# Additional Metrics (You might need to adapt this based on your specific needs)
# Example for recall, assuming you have one-hot encoded labels
from sklearn.metrics import recall_score
recall = recall_score(y_true, y_pred_classes, average='macro')  # Or 'micro', 'weighted', etc.
print(f'Recall: {recall:.4f}')
